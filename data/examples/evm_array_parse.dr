; This example can parse EVM array declarations

#foreign Token ```python Tuple[str, int]```.
#foreign Token ```c++ std::tuple<std::string, int>```.
#foreign Lexeme ```python str```.
#foreign Lexeme ```c++ std::string```.
#foreign ASTNode ```python Tuple```.
#foreign ASTNode ```c++ std::tuple<...>```.

#query type_name(free ASTNode BaseType).

#functor right_corner(bound ASTNode Node, free Token RightCorner) @range(.).
#message next_token(Token Tok, Token NextTok).
#functor lexeme_of_token(bound Token Tok, free Lexeme L) @range(.).
#message expression_starting_at(Token Tok, ASTNode Node).
#functor build_sized_array_type(bound ASTNode BaseType, bound Token LSquare, bound ASTNode SizeExr, bound Token RSquare, free ASTNode ArrayNode) @range(.).
#functor build_empty_array_type(bound ASTNode BaseType, bound Token LSquare, bound Token RSquare, free ASTNode ArrayNode) @range(.).
#message other_type(ASTNode Node).

#constant Lexeme PUNC_R_SQUARE ```"]"```.
#constant Lexeme PUNC_L_SQUARE ```"["```.

type_name(OtherType) : other_type(OtherType).

type_name(ArrayNode)
    : type_name(Node)
    , right_corner(Node, LastTokOfNode)
    , next_token(LastTokOfNode, LSquare)
    , lexeme_of_token(LSquare, PUNC_L_SQUARE)
    , next_token(LSquare, RSquare)
    , lexeme_of_token(RSquare, PUNC_R_SQUARE)
    , build_empty_array_type(Node, LSquare, RSquare, ArrayNode).

type_name(ArrayNode) @highlight
    : type_name(BaseType)
    , right_corner(BaseType, LastTokOfBaseType)
    , next_token(LastTokOfBaseType, LSquare)
    , lexeme_of_token(LSquare, PUNC_L_SQUARE)
    , next_token(LSquare, FirstTokOfSize)
    , expression_starting_at(FirstTokOfSize, SizeExpr)
    , right_corner(SizeExpr, LastTokOfSize)
    , next_token(LastTokOfSize, RSquare)
    , lexeme_of_token(RSquare, PUNC_R_SQUARE)
    , build_sized_array_type(BaseType, LSquare, SizeExpr, RSquare, ArrayNode).

#epilogue ```python
def right_corner_bf(node):
    print("right_corner({})".format(node))
    return node[-1]

def lexeme_of_token_bf(tok: Tuple[str, int]):
    print("lexeme_of_token_bf({})".format(tok))
    return tok[0]

def build_sized_array_type_bbbbf(base_type, lsquare, size, rsquare):
    print("build_sized_array_type_bbbbf({}, {}, {}, {})".format(base_type, lsquare, size, rsquare))
    return (base_type, lsquare, size, rsquare)

def build_empty_array_type_bbbf(base_type, lsquare, rsquare):
    print("build_empty_array_type_bbbf({}, {}, {})".format(base_type, lsquare, rsquare))
    return (base_type, lsquare, rsquare)

if __name__ == "__main__":
    functors = DatabaseFunctors()
    log = DatabaseLog()
    db = Database(log, functors)
    tokens = [("bool", 0), ("[", 1), ("]", 2), ("uint", 3), ("[", 4), ("10", 5), ("]", 6)]
    for i in range(1, len(tokens)):
        db.next_token_2([(tokens[i-1], tokens[i])])
    db.expression_starting_at_2([(tokens[5], (tokens[5],))])
    db.other_type_1([(tokens[0],), (tokens[3],)])
    for t in db.type_name_f():
        print(t)
```.
