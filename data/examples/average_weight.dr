; The purpose of this example is to see how two related but independent
; aggregates behave w.r.t. joins of their inner selects, and joins of their
; results.

#functor latest_i32(bound @i32 OldVal, bound @i32 ProposedVal, free @i32 NewVal) trivial
#functor random_i32(free @i32 RandVal) trivial
#functor div_i32(bound @i32 LHS, bound @i32 RHS, free @i32 Res) trivial
#functor sum_i32(aggregate @i32 Val, summary @i32 Sum) complex
#functor count_i32(aggregate @i32 Val, summary @i32 Count) complex

#local node(@i32 X)
#local edge(@i32 From, @i32 To)
#local edge_weight(@i32 From, @i32 To, @i32 Weight)
#query average_incoming_weight(bound @i32 X, free @i32 Avg)
#message add_edge(@i32 From, @i32 To)

edge(From, To) : add_edge(From, To).
edge_weight(From, To, Weight) : edge(From, To), random_i32(Weight).

node(From) : edge(From, _).
node(To) : edge(_, To).

average_incoming_weight(X, Avg)
  : node(X)
  , sum_i32(AX_Weight, Sum)
      over (@i32 X, @i32 AX_Weight) {
        edge(A, X),
        edge_weight(A, X, AX_Weight)
      }
  , count_i32(BX_Weight, Count)
      over (@i32 X, @i32 BX_Weight) {
        edge(B, X),
        edge_weight(B, X, BX_Weight)
      }
  , div_i32(Sum, Count, Avg).

