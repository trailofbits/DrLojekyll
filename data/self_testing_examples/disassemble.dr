; This example shows how to implement a recursive disassembler with Dr. Lojekyll

#constant u8 FALL_THROUGH 0.
#constant u8 CALL 1.

#message instruction(u64 EA).
#message raw_transfer(u64 FromEA, u64 ToEA, u8 TransferKind).

#local function(ToEA)

    ; The target of a function call is an instruction.
    : raw_transfer(FromEA, ToEA, CALL)
    , instruction(FromEA)
    , instruction(ToEA)

    ; Any instruction without a predecessor is a function.
    : !raw_transfer(_, ToEA, _)
    , instruction(ToEA).

#query function_instructions(bound u64 FuncEA, free u64 InstEA)

    ; The first instruction of a function is a function instruction.
    : function(FuncEA)
    , FuncEA = InstEA

    ; The fall-through of one function instruction is also a function
    ; instruction, assuming it's not a function head.
    : function_instructions(FuncEA, PredEA)
    , raw_transfer(PredEA, InstEA, FALL_THROUGH)
    , !function(InstEA).

#epilogue ```c++
#include <drlojekyll/Runtime/StdRuntime.h>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <iostream>
#include <set>

template <typename DB>
void dump(DB &db) {
  std::cout << "Dump:\n";
  
  for (auto func_ea = 0; func_ea < 50; func_ea++) {
    db.function_instructions_bf(func_ea, [=] (uint64_t inst_ea) {
      std::cout << "  FuncEA=" << func_ea << " InstEA=" << inst_ea << "\n";
      return true;
    });
  }
  std::cout << "\n";
}

template <typename DB>
size_t NumFunctionInstructions(DB &db, uint64_t func_ea) {
  std::vector<uint64_t> eas;
  db.function_instructions_bf(func_ea, [&] (uint64_t inst_ea) {
    eas.push_back(inst_ea);
    return true;
  });
  std::sort(eas.begin(), eas.end());
  auto it = std::unique(eas.begin(), eas.end());
  eas.erase(it, eas.end());
  return eas.size();
}

using DatabaseStorage = hyde::rt::std_containers;

int main() {
  DatabaseFunctors functors;
  DatabaseLog log;
  DatabaseStorage storage;
  Database<DatabaseStorage, DatabaseLog, DatabaseFunctors> db(
      storage, log, functors);

  constexpr uint8_t FALL_THROUGH = 0;
  constexpr uint8_t CALL = 1;
  
  
  // Start with a few instructions, with no control-flow between them.
  hyde::rt::SerializedVector<DatabaseStorage, uint64_t> instructions;
  instructions.Add(10);
  instructions.Add(11);
  instructions.Add(12);
  instructions.Add(13);
  instructions.Add(14);
  instructions.Add(15);
  db.instruction_1(instructions);
  
  dump(db);
  assert(NumFunctionInstructions(db, 9) == 0);
  assert(NumFunctionInstructions(db, 10) == 1);
  assert(NumFunctionInstructions(db, 11) == 1);
  assert(NumFunctionInstructions(db, 12) == 1);
  assert(NumFunctionInstructions(db, 13) == 1);
  assert(NumFunctionInstructions(db, 14) == 1);
  assert(NumFunctionInstructions(db, 15) == 1);  
  
  
  // Now we add the fall-through edges, and 10 is the only instruction with
  // no predecessor, so its the function head.
  hyde::rt::SerializedVector<DatabaseStorage, uint64_t, uint64_t, uint8_t>
      transfers;
  
  transfers.Add(10, 11, FALL_THROUGH);
  transfers.Add(11, 12, FALL_THROUGH);
  transfers.Add(12, 13, FALL_THROUGH);
  transfers.Add(13, 14, FALL_THROUGH);
  transfers.Add(14, 15, FALL_THROUGH);
  db.raw_transfer_3(transfers);
  
  dump(db);
  assert(NumFunctionInstructions(db, 9) == 0);
  assert(NumFunctionInstructions(db, 10) == 6);
  assert(NumFunctionInstructions(db, 11) == 0);
  assert(NumFunctionInstructions(db, 12) == 0);
  assert(NumFunctionInstructions(db, 13) == 0);
  assert(NumFunctionInstructions(db, 14) == 0);
  assert(NumFunctionInstructions(db, 15) == 0);
  
  
  // Now add the instruction 9. It will show up as a function head, because
  // it has no predecessors. The rest will stay the same because there is
  // no changes to control-flow.
  hyde::rt::SerializedVector<DatabaseStorage, uint64_t> instructions2;
  instructions2.Add(9);
  db.instruction_1(instructions2);
  
  dump(db);
  assert(NumFunctionInstructions(db, 9) == 1);
  assert(NumFunctionInstructions(db, 10) == 6);
  assert(NumFunctionInstructions(db, 11) == 0);
  assert(NumFunctionInstructions(db, 12) == 0);
  assert(NumFunctionInstructions(db, 13) == 0);
  assert(NumFunctionInstructions(db, 14) == 0);
  assert(NumFunctionInstructions(db, 15) == 0);
  
  
  // Now add a fall-through between 9 and 10. 10 now has a successor, so it's
  // not a function head anymore, so all of the function instructions transfer
  // over to function 9.
  hyde::rt::SerializedVector<DatabaseStorage, uint64_t, uint64_t, uint8_t>
      transfers2;
  transfers2.Add(9, 10, FALL_THROUGH);
  db.raw_transfer_3(transfers2);
  
  dump(db);
  assert(NumFunctionInstructions(db, 9) == 7);
  assert(NumFunctionInstructions(db, 10) == 0);
  assert(NumFunctionInstructions(db, 11) == 0);
  assert(NumFunctionInstructions(db, 12) == 0);
  assert(NumFunctionInstructions(db, 13) == 0);
  assert(NumFunctionInstructions(db, 14) == 0);
  assert(NumFunctionInstructions(db, 15) == 0);

  
  // Now add a function call between 10 and 14. That makes 14 look like
  // a function head, and so now that 14 is a function head, it's no longer
  // part of function 9.
  hyde::rt::SerializedVector<DatabaseStorage, uint64_t, uint64_t, uint8_t>
      transfers3;
  transfers3.Add(10, 14, CALL);
  db.raw_transfer_3(transfers3);
  
  dump(db);
  assert(NumFunctionInstructions(db, 9) == 5);
  assert(NumFunctionInstructions(db, 10) == 0);
  assert(NumFunctionInstructions(db, 11) == 0);
  assert(NumFunctionInstructions(db, 12) == 0);
  assert(NumFunctionInstructions(db, 13) == 0);
  assert(NumFunctionInstructions(db, 14) == 2);
  assert(NumFunctionInstructions(db, 15) == 0);

  return 0;
}
```.

#epilogue ```python

def dump(db):
  print("Dump:")
  for i in range(0, 50):
    for ea in db.function_instructions_bf(i):
      print("  FuncEA={} InstEA={}".format(i, ea))
  print()

FALL_THROUGH = 0
CALL = 1

if __name__ == "__main__":
  db = Database(DatabaseLog(), DatabaseFunctors())

  # Start with a few instructions, with no control-flow between them.
  db.instruction_1([10, 11, 12, 13, 14, 15])
  dump(db)


  # At first, every instruction looks like a function head, because we have no
  # transfers. Note: instruction 9 doesn't exist yet.

  assert len(set(db.function_instructions_bf(9))) == 0
  assert len(set(db.function_instructions_bf(10))) == 1
  assert len(set(db.function_instructions_bf(11))) == 1
  assert len(set(db.function_instructions_bf(12))) == 1
  assert len(set(db.function_instructions_bf(13))) == 1
  assert len(set(db.function_instructions_bf(14))) == 1
  assert len(set(db.function_instructions_bf(15))) == 1



  # Now we add the fall-through edges, and 10 is the only instruction with
  # no predecessor, so its the function head.


  db.raw_transfer_3([(10, 11, FALL_THROUGH),
                     (11, 12, FALL_THROUGH),
                     (12, 13, FALL_THROUGH),
                     (13, 14, FALL_THROUGH),
                     (14, 15, FALL_THROUGH)])
  dump(db)


  assert len(set(db.function_instructions_bf(9))) == 0
  assert len(set(db.function_instructions_bf(10))) == 6
  assert len(set(db.function_instructions_bf(11))) == 0
  assert len(set(db.function_instructions_bf(12))) == 0
  assert len(set(db.function_instructions_bf(13))) == 0
  assert len(set(db.function_instructions_bf(14))) == 0
  assert len(set(db.function_instructions_bf(15))) == 0


  db.instruction_1([9])
  dump(db)

  assert len(set(db.function_instructions_bf(9))) == 1
  assert len(set(db.function_instructions_bf(10))) == 6
  assert len(set(db.function_instructions_bf(11))) == 0
  assert len(set(db.function_instructions_bf(12))) == 0
  assert len(set(db.function_instructions_bf(13))) == 0
  assert len(set(db.function_instructions_bf(14))) == 0
  assert len(set(db.function_instructions_bf(15))) == 0


  db.raw_transfer_3([(9, 10, FALL_THROUGH)])
  dump(db)

  assert len(set(db.function_instructions_bf(9))) == 7
  assert len(set(db.function_instructions_bf(10))) == 0
  assert len(set(db.function_instructions_bf(11))) == 0
  assert len(set(db.function_instructions_bf(12))) == 0
  assert len(set(db.function_instructions_bf(13))) == 0
  assert len(set(db.function_instructions_bf(14))) == 0
  assert len(set(db.function_instructions_bf(15))) == 0


  db.raw_transfer_3([(10, 14, CALL)])
  dump(db)

  assert len(set(db.function_instructions_bf(9))) == 5
  assert len(set(db.function_instructions_bf(10))) == 0
  assert len(set(db.function_instructions_bf(11))) == 0
  assert len(set(db.function_instructions_bf(12))) == 0
  assert len(set(db.function_instructions_bf(13))) == 0
  assert len(set(db.function_instructions_bf(14))) == 2
  assert len(set(db.function_instructions_bf(15))) == 0
```.
