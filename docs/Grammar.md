# Formal Syntax

The following BNF grammar describes the formal syntax of Dr. Lojekyll modules.
Dr. Lojekyll modules begin with zero-or-more import directives, followed by
zero-or-more declarations, and end with zero-or-more clause definitions.

All defined clauses must be preceded by a declaration of the same name and
arity. Clauses cannot be defined for functors, which are implemented by native
code extension modules.

## Modules

A Dr. Lojekyll file is called a module. One module can import another module, and
imports can be cyclic. Modules begin with a list of zero-or-more import statements.
Imports must precede all other declarations or clause definitions.

After imports, clauses and declarations can appear in any order. The only
requirement is that all uses of predicates or functors in clause bodies, as well as all
clause heads, lexically follow declarations of the used entities. Thus, one cannot use
a predicate before it is declared.

Due to some laziness in the parser and the way that globally visible symbols work,
one can appear to use things like `#export`, `#query`, and `#message` entities before
they are declared. This is possible if a declaration is visible in another module that
is imported before your current module.  

```antlr
module: import_list clause_or_decl_list ;

import_list: import import_list ;
import_list: ;

clause_or_decl_list: decl clause_or_decl_list ;
clause_or_decl_list: inline_code clause_or_decl_list ;
clause_or_decl_list: clause clause_or_decl_list ;
clause_or_decl_list: ;
```

## Imports

One module can import another module.

```
import: "#import" <double quoted string literal>
```

For example, suppose that the file `/path/to/hello.dr` is contains the following import
statement:

```
#import "test.dr"
```

If the compiler is invoked with the current working directory set to `/tmp`, and if
the invocation specifies two module search paths, `-M /usr/lib -M /usr/local/lib`, then
the search paths tested when trying to find `test.dr` are as follows:

 * `/path/to/test.dr`
 * `/usr/lib/test.dr`
 * `/usr/local/lib/test.dr`
 
The current working directory of the compiler invocation is used as the default
initial search path for the modules specified at the command line. Therefore, if the
compiler has been invoked on the file `hello.dr` (and not `/path/to/hello.dr`) then it
would have searched for `hello.dr` as follows:

 * `/tmp/test.dr`
 * `/usr/lib/test.dr`
 * `/usr/local/lib/test.dr`

## Inlining target-specific code into modules

Target-specific code can be inlined directly into the code generated by the compiler.
There are two ways of specificing code to be inlined: `#prologue` code, which is placed
near the beginning of the code generated by the compiler, and `#epilogue` code, which is
placed at the end of the code generated by the compiler. A common pattern is to use
`#prologue` code to embed Python `import` statements, or C++ `#include` directives.
Another common pattern is to use `#epilogue` code to embed self-tests.

```antlr
// Single and multi-line code blocks
code_data: "```" <anything...> "```" ;
code_data: "```c++" <anything...> "```" ;
code_data: "```python" <anything...> "```" ;
code_data: <double quoted string literal> ;

// Inline code statements to be emitted to the generated code.
code_decl: "#prologue" code_data ;
code_decl: "#epilogue" code_data ;
```

Inlined code can be target-language-specific, or generic. For example, the code
`hello world` will be emitted into Python and C++ code, when generated.

```
#prologue ```hello world```
```

However, a code block can be tagged with a target language. For example, the code
`fizz buzz` will only be emitted into Python code, and the code `foo bar` will only be
emitted into C++ code.

```
#prologue ```python fizz buzz```
#prologue ```c++ foo bar```
```

Inline code blocks can span multiple lines. Leading and trailing empty lines will be
stripped.

## Types

Dr. Lojekyll supports several built-in type representations, as well as provides
a mechanism to declare "foreign types," i.e. types whose representation is defined
in the target code generation language.

### Built-in Types

The following type names are built-in.

```antlr

// Signed integer types.
type: "i8" ;
type: "i16" ;
type: "i32" ;
type: "i64" ;

// Unsigned integer types.
type: "u8" ;
type: "u16" ;
type: "u32" ;
type: "u64" ;

// Floating point types.
type: "f32" ;
type: "f64" ;

// String types.
type: "utf8" ;
type: "ascii" ;
type: "bytes" ;

// Other.
type: "uuid" ;
type: <foreign type name> ;
```

### Foreign Types

Foreign types are a mechanism for describing objects in the target code
generation language to Dr. Lojekyll. They are opaque to Dr. Lojekyll 
insofar as, from within Datalog code, that are used by their type names 
alone, and no "property access" exists. It is common to use foreign type 
declarations with foreign constants and functors. Foreign type names 
can begin with upper or lower case alphabetic characters.

```antlr
foreign_type_name: atom ;
foreign_type_name: variable ;

foreign_decl: "#foreign" foreign_type_name ;
foreign_decl: "#foreign" foreign_type_name code_data ;
foreign_decl: "#foreign" foreign_type_name code_data "```" <anything containing one $> "```" ;
foreign_decl: "#foreign" foreign_type_name code_data <double quoted string containing one $> ;
```

Foreign types can be forward declared, e.g. `#foreign Foo`. This lets modules
use these foreign types easily without having to repeat code generation
specifications for the foreign type. All foreign types must have at least 
one code generation declaration.

For example, the following declares the `IntPair` type as being represented in C++
as `std::pair<int, int>`.

```
#foreign IntPair ```c++ std::pair<int, int>``` 
```

In some cases, we may want to designate a target-specific constuctor for a foreign
type. For example, one could define a custom 8-bit integer type in Python as follows.

```
#foreign Int8 ```python int``` ```int(($) & 0xff)```
```

In the above example, the second code block (which is never given a language prefix)
specifies the constructor pattern for `Int8` values. The `$` symbol (which must be present,
and only used once) specifies where a value is substituted. This particular example allows
us to represent the class of 8-bit integers in terms of Python's infinite precision `int`
type.

## Declarations

There are several categories of declarations.

 * **Exports.** An export is a relational predicate that is visible to other modules.
 Two exports that share the same name, but are declared in different modules, are
 treated as being logically the same if they have the same number of parameters. Export
 names must begin with a lower case alphabetical character.
 
 
 * **Locals.** A local is a relational predicate that is only visible within the
 current module. Within a module, two locals declarations with the same name are 
 treated as being logical equivalents if they have the same number of parameters.
 Local names must begin with a lower case alphabetical character.
 
 
 * **Queries.** A query is a relational predicate that is made externally visible
 to target code for the sake of reading/extracting data from the database. As its name
 implies, it is a "pre-packaged query," somewhat like a prepared statement in
 SQL-based relational databases. Within Datalog, queries have similar visibility
 rules to exports. They are visible across module boundaries, and can be re-declared.
 Re-declarations of queries can have tangible side-effects. For example, two variants
 of the same-named query, with the same number of parameters can be declared, but
 will be logically different if they have different binding specifiers on their
 parameters. Query names must begin with a lower case alphabetical character.
 
 
 * **Messages.** Messages are a mechanism of sending data into the database or
 receiving updates from the database. A given message can only be used either always
 for receiving, or always for sending. If a message appears in a clause body, then it
 is received by Datalog. If appears in a clause head, then it is sent by Datalog to
 the outside world. The mechanics of sending/receiving are specific to target code
 generation. Message names must begin with a lower case alphabetical character.
 
 
 * **Functors.** Functors are a mechanism for Datalog code to invoke procedural code
 in the target language. They are globally visible, similar to export declarations.
 Like query declarations, re-declarations are considered distinct if the binding
 attributes of their parameters are different. Functor names must begin with a
 lower case alphabetical character.
 
 
 * **Named constants.** Named constants are declarations that can be used
 to provide semantically meaningful names to constants of a built-in type (e.g. `i32`) or
 to reference constants of a foreign type (e.g. to represent enumeration constants from
 C++). Named constant names can begin with either upper or lowercase alphabetic characters.
 

```antlr
// Declarations generally must fit inside a single line. They are allowed
// to span multiple lines, but only if the new line characters exist
// within the matched parantheses of their parameter lists.
decl: export_decl ;
decl: local_decl ;
decl: functor_decl ;
decl: message_decl ;
decl: query_decl ;
decl: foreign_decl ;
decl: constant_decl ;

message_decl: "#message" atom "(" param_list_0 ")" "\n" ;
export_decl: "#export" atom "(" param_list_1 ")" "\n" ;
local_decl: "#local" atom "(" param_list_1 ")" maybe_inline "\n" ;
query_decl: "#query" atom "(" param_list_3 ")" "\n" ;

constant_decl: "#constant" foreign_type_name code_data ;

maybe_inline: "inline" ;
maybe_inline: ;


param_list_0: type named_var "," param_list_0 ;
param_list_0: type named_var ;

param_list_1: type named_var "," param_list_1 ;
param_list_1: named_var "," param_list_1 ;
param_list_1: type named_var ;
param_list_1: "mutable" "(" atom ")" named_var ;
param_list_1: named_var ;


param_list_3: binding_specifier type named_var "," param_list_3 ;
param_list_3: binding_specifier type named_var ;

atom: r"[a-z][A-Za-z0-9_]*" ;
named_var: r"[A-Z][A-Za-z0-9_]*" ;
anon_var: r"_[A-Za-z0-9_]*" ;

var: named_var ;
var: anon_var ;

binding_specifier: "bound" ;
binding_specifier: "free" ;

binding_specifier_2: binding_specifier ;
binding_specifier_2: "aggregate" ;
binding_specifier_2: "summary" ;
```

### Functors

Functor declarations support more variety than other declaration forms.
Functors can be used for aggregates, and thus have `aggregate` and `summary`
binding attributes along with `bound` and `free`. They can also specify
a range, such as `range(.)` to say that the functor produces a single
output (for the set of `free`-attributed variables) given its input
`bound`-attributed parameters.

```antlr

functor_decl: "#functor" atom "(" param_list_2 ")" constraints "\n" ;

constraints: ;
constraints: "range" "(" "." ")" constraints ;
constraints: "range" "(" "+" ")" constraints ;
constraints: "range" "(" "*" ")" constraints ;
constraints: "range" "(" "?" ")" constraints ;
constraints: "impure" constraints ;

param_list_2: binding_specifier_2 type named_var "," param_list_2 ;
param_list_2: binding_specifier_2 type named_var ;

```

#### Functor Ranges

Acceptable values of `X` in `range(X)` for use in range specifiers are documented below.

| **Range** | **Interpretation**                                                                             |
|-------|--------------------------------------------------------------------------------------------|
| ?     | Zero-or-one: An output may or may not be produced.                                         |
| .     | One-to-one: A single output is always produced.                                            |
| +     | One-or-more: At least one output is always produced, though more than one may be produced. |
| *     | Zero-or-more: Any number of outputs may be produced, including zero.                       |


## Clauses

Clauses represent the rules of Datalog. They have two logical parts:

 * **Head.** The head of the clause is what is proven. A clause head is proven
 if all of the conditions in the clause body are satisfied. Sometimes just a clause
 head is provided, in which case the clause is trivially true. Once proven, a clause
 head is treated as a new fact that can be leveraged to prove more facts.

 
 * **Body.** The body of a clause contains the conditions which must be satisfied
 in order to prove the head. The clause is a conjunction of predicates, where the
 logical "and" operation is represented by a comma. Sometimes, it can be helpful
 to think of commas as introducing nested loops.


Clauses can be defined for queries, messages, exports, and locals. Clauses
cannot be defined for functors.


```antlr
clause_head_pragma: "@highlight" ;
clause_head_pragma: ;

clause: atom "(" named_var_list ")" clause_head_pragma "." ;
clause: atom "(" named_var_list ")" clause_head_pragma ":" conjunct_list "." ;
clause: "!" atom "(" named_var_list ")" "." ;
clause: "!" atom "(" named_var_list ")" ":" conjunct_list "." ;
clause: atom ":" conjunct_list "." ;

named_var_list: named_var "," named_var_list ;
named_var_list: named_var ;

conjunct_list: comparison conjunct_list_tail ;
conjunct_list: predicate conjunct_list_tail ;
conjunct_list: negation conjunct_list_tail ;
conjunct_list: predicate "over" aggregation conjunct_list_tail ;

aggregation: predicate ;
aggregation: "(" param_list_0 ")" "{" conjunct_list "}" ;

var_or_literal: var ;
var_or_literal: literal ;

comparison: var_or_literal "=" var_or_literal ;
comparison: var_or_literal "!=" var_or_literal ;
comparison: var_or_literal "<" var_or_literal ;
comparison: var_or_literal ">" var_or_literal ;

predicate: atom ;
predicate: atom "(" arg_list ")" ;
negation: "!" predicate ;

conjunct_list_tail: "," conjunct_list ;
conjunct_list_tail: ;

arg_list: var_or_literal "," arg_list ;
arg_list: var_or_literal ;

literal: "0" ;
literal: r"[1-9][0-9]*" ;
literal: r"0[1-7][0-7]*"
literal: r"0x[1-9a-fA-F][0-9a-fA-F]*"
literal: r"[1-9][0-9]*[.][0-9]+"
literal: <double quoted string literal>
```

### Positive Clauses


A positive clause is a normal clause that starts with an "atom", i.e.
an identifier that begins with a lower case, alphabetic character. These
are associated with queries, messages, exports, and locals.

A positive clause can be thought as "additive": when the conditions of
its body are satisfied, its head is "added to" to the set of proven facts.
When a message declaration is used in the head of a clause, the clause is
treated as "message publication," i.e. when the conditions are satisfied,
the outside world is told about the addition (or removal, in some cases)
of that proven fact. The outside world may observe the same message published
multiple times.

In the following code, `tc(From, To)` is the clause head, and everything
between the `:` and the `.` is the clause body.

```
tc(From, To) : tc(From, X), tc(X, To).
```

### Negative Clauses

A negative clause is a mechanism that allows for the removal of facts.
Syntactically, a negative clause is a normal clause that begins with a `!`.
Semantically, a negative clause must depend on a message in its body, and
all other positive/negative clauses sharing the same name and parameter count
must also directly depend on messages.

For example, the following code maintains a relation `edge(F, T)` that
keeps track of edges in a hypothetical graph. When the code receives an
`add_edge` message, an edge is added to the `edge` relation if it is not
yet present. When a `remove_edge` message is received, data is removed
from the `edge` relation if it is present.

```
#message add_edge(u32 F, u32 T)
#message remove_edge(u32 F, u32 T)
#export edge(F, T)

edge(F, T) : add_edge(F, T).
!edge(F, T) : remove_edge(F, T).

```
