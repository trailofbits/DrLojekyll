# Formal Syntax

The following BNF grammar describes the formal syntax of Dr. Lojekyll modules.
Dr. Lojekyll modules begin with zero-or-more import directives, followed by
zero-or-more declarations, and end with zero-or-more clause definitions.

All defined clauses must be preceded by a declaration of the same name and
arity. Clauses cannot be defined for functors, which are implemented by native
code extension modules.

## Modules

A Dr. Lojekyll file is called a module. One module can import another module, and
imports can be cyclic. Modules begin with a list of zero-or-more import statements.
Imports must precede all other declarations or clause definitions.

After imports, clauses and declarations can appear in any order. The only
requirement is that all uses of predicates or functors in clause bodies, as well as all
clause heads, lexically follow declarations of the used entities. Thus, one cannot use
a predicate before it is declared.

Due to some laziness in the parser and the way that globally visible symbols work,
one can appear to use things like `#export`, `#query`, and `#message` entities before
they are declared. This is possible if a declaration is visible in another module that
is imported before your current module.  

```antlr
module: import_list clause_or_decl_list ;

import_list: import import_list ;
import_list: ;

clause_or_decl_list: decl clause_or_decl_list ;
clause_or_decl_list: inline_code clause_or_decl_list ;
clause_or_decl_list: clause clause_or_decl_list ;
clause_or_decl_list: ;
```

## Imports

One module can import another module.

```
import: "#import" <double quoted string literal> "."
```

For example, suppose that the file `/path/to/hello.dr` is contains the following import
statement:

```
#import "test.dr".
```

If the compiler is invoked with the current working directory set to `/tmp`, and if
the invocation specifies two module search paths, `-M /usr/lib -M /usr/local/lib`, then
the search paths tested when trying to find `test.dr` are as follows:

 * `/path/to/test.dr`
 * `/usr/lib/test.dr`
 * `/usr/local/lib/test.dr`
 
The current working directory of the compiler invocation is used as the default
initial search path for the modules specified at the command line. Therefore, if the
compiler has been invoked on the file `hello.dr` (and not `/path/to/hello.dr`) then it
would have searched for `hello.dr` as follows:

 * `/tmp/test.dr`
 * `/usr/lib/test.dr`
 * `/usr/local/lib/test.dr`

## Inlining target-specific code into modules

Target-specific code can be inlined directly into the code generated by the compiler.
There are two ways of specificing code to be inlined: `#prologue` code, which is placed
near the beginning of the code generated by the compiler, and `#epilogue` code, which is
placed at the end of the code generated by the compiler. A common pattern is to use
`#prologue` code to embed Python `import` statements, or C++ `#include` directives.
Another common pattern is to use `#epilogue` code to embed self-tests.

```antlr
// Single and multi-line code blocks
code_data: "```" <anything...> "```" ;
code_data: "```c++" <anything...> "```" ;
code_data: "```python" <anything...> "```" ;
code_data: "```flat" <anything...> "```" ;
code_data: <double quoted string literal> ;

cxx_target: "server" ":" ;
cxx_target: "client" ":" ;
cxx_target: "database" ":" ;
cxx_target: "interface" ":" ;

cxx_inline_stage: cxx_target "prologue" ;
cxx_inline_stage: cxx_target "epiogue" ;

inline_stage: "c++" ":" cxx_inline_stage ;
inline_stage: "flat" ":" flat_inline_stage ;
inline_stage: "python" ":" py_inline_stage ;

// Inline code statements to be emitted to the generated code.
code_decl: "#inline" "(" inline_stage ")" code_data "." ;
```

Inlined code can be target-language-specific, or generic. For example, the code
`hello world` will be emitted into Python and C++ code, when generated.

```
#prologue ```hello world```.
```

However, a code block can be tagged with a target language. For example, the code
`fizz buzz` will only be emitted into Python code, and the code `foo bar` will only be
emitted into C++ code.

```
#prologue ```python fizz buzz```.
#prologue ```c++ foo bar```.
```

Inline code blocks can span multiple lines. Leading and trailing empty lines will be
stripped.

## Types

Dr. Lojekyll supports several built-in type representations, as well as provides
a mechanism to declare "foreign types," i.e. types whose representation is defined
in the target code generation language.

### Built-in Types

The following type names are built-in.

```antlr

// Signed integer types.
integral_type_name: "i8" ;
integral_type_name: "i16" ;
integral_type_name: "i32" ;
integral_type_name: "i64" ;

// Unsigned integer types.
integral_type_name: "u8" ;
integral_type_name: "u16" ;
integral_type_name: "u32" ;
integral_type_name: "u64" ;

type: integral_type_name ;

// Floating point types.
type: "f32" ;
type: "f64" ;

// String types.
type: "bytes" ;

// Other.
type: "bool" ;
type: <foreign type name> ;
```

### Foreign Types

Foreign types are a mechanism for describing objects in the target code
generation language to Dr. Lojekyll. They are opaque to Dr. Lojekyll 
insofar as, from within Datalog code, that are used by their type names 
alone, and no "property access" exists. It is common to use foreign type 
declarations with foreign constants and functors. Foreign type names 
can begin with upper or lower case alphabetic characters.

```antlr
foreign_type_name: atom ;
foreign_type_name: variable ;

// Marks this type (possibly for a specific language target) as being referentially
// transparent. That tells the compiler that equality implies identity. If a foreign
// type is not marked as transparent, then the compiler will emit code that deduplicates
// and interns equal instances so that all uses are identical.
foreign_decl_pragmas: "@transparent" ;
foreign_decl_pragmas: ;

foreign_decl: "#foreign" foreign_type_name "." ;
foreign_decl: "#foreign" foreign_type_name code_data foreign_decl_pragmas "." ;
foreign_decl: "#foreign" foreign_type_name code_data "```" <anything containing one $> "```" foreign_decl_pragmas "." ;
foreign_decl: "#foreign" foreign_type_name code_data <double quoted string containing one $> foreign_decl_pragmas "." ;
```

Foreign types can be forward declared, e.g. `#foreign Foo`. This lets modules
use these foreign types easily without having to repeat code generation
specifications for the foreign type. All foreign types must have at least 
one code generation declaration.

For example, the following declares the `IntPair` type as being represented in C++
as `std::pair<int, int>`.

```
#foreign IntPair ```c++ std::pair<int, int>```.
```

In some cases, we may want to designate a target-specific constuctor for a foreign
type. For example, one could define a custom 8-bit integer type in Python as follows.

```
#foreign Int8 ```python int``` ```int(($) & 0xff)```.
```

In the above example, the second code block (which is never given a language prefix)
specifies the constructor pattern for `Int8` values. The `$` symbol (which must be present,
and only used once) specifies where a value is substituted. This particular example allows
us to represent the class of 8-bit integers in terms of Python's infinite precision `int`
type.


### Enumeration Types

Enumeration types mirror their C or C++ counterparts: they are named integral
types. Enumerator constants are "added" to enumerations using `#constant`.

```antlr
enum_decl: "#enum" foreign_type_name integral_type_name "." ; 

```

## Declarations

There are several categories of declarations. All declarations must end with a period.

 * **Exports.** An export is a relational predicate that is visible to other modules.
 Two exports that share the same name, but are declared in different modules, are
 treated as being logically the same if they have the same number of parameters. Export
 names must begin with a lower case alphabetical character.
 
 
 * **Locals.** A local is a relational predicate that is only visible within the
 current module. Within a module, two locals declarations with the same name are 
 treated as being logical equivalents if they have the same number of parameters.
 Local names must begin with a lower case alphabetical character.
 
 
 * **Queries.** A query is a relational predicate that is made externally visible
 to target code for the sake of reading/extracting data from the database. As its name
 implies, it is a "pre-packaged query," somewhat like a prepared statement in
 SQL-based relational databases. Within Datalog, queries have similar visibility
 rules to exports. They are visible across module boundaries, and can be re-declared.
 Re-declarations of queries can have tangible side-effects. For example, two variants
 of the same-named query, with the same number of parameters can be declared, but
 will be logically different if they have different binding specifiers on their
 parameters. Query names must begin with a lower case alphabetical character.
 
 
 * **Messages.** Messages are a mechanism of sending data into the database or
 receiving updates from the database. A given message can only be used either always
 for receiving, or always for sending. If a message appears in a clause body, then it
 is received by Datalog. If appears in a clause head, then it is sent by Datalog to
 the outside world. The mechanics of sending/receiving are specific to target code
 generation. Message names must begin with a lower case alphabetical character.
 
 
 * **Functors.** Functors are a mechanism for Datalog code to invoke procedural code
 in the target language. They are globally visible, similar to export declarations.
 Like query declarations, re-declarations are considered distinct if the binding
 attributes of their parameters are different. Functor names must begin with a
 lower case alphabetical character.
 
 
 * **Named constants.** Named constants are declarations that can be used
 to provide semantically meaningful names to constants of a built-in type (e.g. `i32`) or
 to reference constants of a foreign type (e.g. to represent enumeration constants from
 C++). Named constant names can begin with either upper or lowercase alphabetic characters.
 

```antlr
// All declarations are terminated with a period.
// All newline characters within the declaration are ignored.
decl: export_decl ;
decl: local_decl ;
decl: functor_decl ;
decl: message_decl ;
decl: query_decl ;
decl: foreign_decl ;
decl: enum_decl ;
decl: constant_decl ;
decl: database_decl ;

database_decl: "#database" atom "." ;
database_decl: "#database" named_var "." ;

message_decl: "#message" atom "(" param_list_0 ")" maybe_differential "." ;
export_decl: "#export" atom "(" param_list_1 ")" finish_decl_or_start_clause ;
local_decl: "#local" atom "(" param_list_1 ")" maybe_inline finish_decl_or_start_clause ;
query_decl: "#query" atom "(" param_list_3 ")" maybe_first finish_decl_or_start_clause;

finish_decl_or_start_clause : "." ;
finish_decl_or_start_clause : ":" conjunct_list "." ;

constant_decl: "#constant" foreign_type_name code_data constant_pragmas "." ;

// Tells the compile that a foreign constant has a unique representation that
// is distinct from every other constant/foreign constant of the same type. This
// helps the compiler be slightly more aggressive in some optimization cases.
//
// In general, the compiler doesn't try to interpret the equality of two constants,
// even integral literals. For example, it doesn't know that `0x1` and `1` are the
// same.
constant_pragmas: "@unique" ;
constant_pragmas: ;

// Marks a received or published message as differential. Required if absent
// and analysis determines that a published message actually admits retractions.
// Key idea is that it helps document and clearly define what things admit
// diffrentials, as they often creep into code because of usage of negations.
maybe_differential: "@differential" ;
maybe_differential: ;

// Marks a `#local` or `#export` declaration as being inlinable into its usage
// sites. Inlining is not yet done, but when it is added, this will enable
// `@inline`-marked rules to not (themselves) be subject to range-restriction,
// but instead rely on their inlining into other clause bodies to restrict all
// variables.
maybe_inline: "@inline" ;
maybe_inline: ;

// Only return the first result from a `#query` declaration.
maybe_first: "@first" ;
maybe_first: ;

param_list_0: type named_var "," param_list_0 ;
param_list_0: type named_var ;

param_list_1: type named_var "," param_list_1 ;
param_list_1: named_var "," param_list_1 ;
param_list_1: type named_var ;
param_list_1: "mutable" "(" atom ")" named_var ;
param_list_1: named_var ;


param_list_3: binding_specifier type named_var "," param_list_3 ;
param_list_3: binding_specifier type named_var ;

atom: r"[a-z][A-Za-z0-9_]*" ;
named_var: r"[A-Z][A-Za-z0-9_]*" ;
anon_var: r"_[A-Za-z0-9_]*" ;

var: named_var ;
var: anon_var ;

binding_specifier: "bound" ;
binding_specifier: "free" ;

binding_specifier_2: binding_specifier ;
binding_specifier_2: "aggregate" ;
binding_specifier_2: "summary" ;
```

### Functors

Functor declarations support more variety than other declaration forms.
Functors can be used for aggregates, and thus have `aggregate` and `summary`
binding attributes along with `bound` and `free`. They can also specify
a range, such as `@range(.)` to say that the functor produces a single
output (for the set of `free`-attributed variables) given its input
`bound`-attributed parameters.

Functor declarations can also be marked as `@inline`. This means that they
are provided by function, and not via the `DatalogFunctors` class which is
code-generated.

```antlr

functor_decl: "#functor" atom "(" param_list_2 ")" constraints "." ;

constraints: ;
constraints: "@range" "(" "." ")" constraints ;
constraints: "@range" "(" "+" ")" constraints ;
constraints: "@range" "(" "*" ")" constraints ;
constraints: "@range" "(" "?" ")" constraints ;
constraints: "@impure" constraints ;
constraints: "@inline" "(" code_data ")" constraints ;
constraints: "@inline" constraints ;

param_list_2: binding_specifier_2 type named_var "," param_list_2 ;
param_list_2: binding_specifier_2 type named_var ;

```

#### Functor Ranges

Acceptable values of `X` in `range(X)` for use in range specifiers are documented below.

| **Range** | **Interpretation**                                                                             |
|-------|--------------------------------------------------------------------------------------------|
| ?     | Zero-or-one: An output may or may not be produced.                                         |
| .     | One-to-one: A single output is always produced.                                            |
| +     | One-or-more: At least one output is always produced, though more than one may be produced. |
| *     | Zero-or-more: Any number of outputs may be produced, including zero.                       |


## Clauses

Clauses represent the rules of Datalog. They have two logical parts:

 * **Head.** The head of the clause is what is proven. A clause head is proven
 if all of the conditions in the clause body are satisfied. Sometimes just a clause
 head is provided, in which case the clause is trivially true. Once proven, a clause
 head is treated as a new fact that can be leveraged to prove more facts.

 
 * **Body.** The body of a clause contains the conditions which must be satisfied
 in order to prove the head. The clause is a conjunction of predicates, where the
 logical "and" operation is represented by a comma. Sometimes, it can be helpful
 to think of commas as introducing nested loops.


Clauses can be defined for queries, messages, exports, and locals. Clauses
cannot be defined for functors.


```antlr
// Used for debugging the DataFlow IR when visualized using DOT digraphs.
// A random color is used to highlight the borders of data flow IR nodes
// associated with the clause.
clause_head_pragma: "@highlight" ;

// Tells the compiler that you are aware that a cross-produce is necessary,
// essentially "blessing" it to generate what it assumes is bad performing
// code. Sometimes cross-products are not desirable and come about by
// accident, and so they are always treated as errors in the source code
// unless otherwise so blessed.
clause_head_pragma: "@product" ;

clause_head_pragma: ;

clause: atom "(" named_var_list ")" clause_head_pragma "." ;
clause: atom "(" named_var_list ")" clause_head_pragma ":" conjunct_list "." ;
clause: atom ":" conjunct_list "." ;

named_var_list: named_var "," named_var_list ;
named_var_list: named_var ;

conjunct_list: comparison conjunct_list_tail ;
conjunct_list: predicate conjunct_list_tail ;
conjunct_list: negation conjunct_list_tail ;
conjunct_list: predicate "over" aggregation conjunct_list_tail ;

// Introduces a kind of happens-before relation into the clause body, that
// forces things before the barrier to be joined together as much as possible,
// and then when that is done, joins things after the barrier. This helps
// to encourage the dataflow builder to build user-intended pipelines.
conjunct_list: "@barrier" conjunct_list_tail ;

aggregation: predicate ;
aggregation: "(" param_list_0 ")" "{" conjunct_list "}" ;

var_or_literal: var ;
var_or_literal: literal ;

comparison: var_or_literal "=" var_or_literal ;
comparison: var_or_literal "!=" var_or_literal ;
comparison: var_or_literal "<" var_or_literal ;
comparison: var_or_literal ">" var_or_literal ;

// A variable can be used as a predicate if it has Boolean type. This
predicate_tail: var ;

// Booleans can be used as predicates, even though their evaluation
// is mostly trivial. Adding in `false` or `!true` as a predicate is
// a simple way to disable a rule, without commenting it out. The effect
// on codegen will be as though it has been commented out, although that
// rule will still be subject to type checking.
predicate_tail: "true" ;
predicate_tail: "false" ;

// An atom name can be used as a zero-argument predicate. These behave
// like existence checks. Zero argument predicates can be used before they
// are defined.
predicate_tail: atom ;

predicate_tail: atom "(" arg_list ")" ;

predicate: predicate_tail ;
predicate: "!" predicate_tail ;

// Never is a stronger form of negation that brings in programmer/system
// knowledge that cannot be inferred. It tells the compiler that once
// a particular negation is satisfied, it will always be satisfied. This
// is a strong statement, as it says that future inputs (directly or
// indirectly via `#message`s) will never lead to the negated predicate
// being proven true.
predicate: "@never" atom "(" arg_list ")" ;

conjunct_list_tail: "," conjunct_list ;
conjunct_list_tail: ;

arg_list: var_or_literal "," arg_list ;
arg_list: var_or_literal ;

literal: "0" ;
literal: r"[1-9][0-9]*" ;
literal: r"0[1-7][0-7]*"
literal: r"0x[1-9a-fA-F][0-9a-fA-F]*"
literal: r"[1-9][0-9]*[.][0-9]+"
literal: <double quoted string literal>
literal: "true" ;
literal: "false" ;
```

All clause heads start with an "atom", i.e. an identifier that begins with
a lower case, alphabetic character. These are associated with queries,
messages, exports, and locals.

Clause can be thought as "additive": when the conditions of its body are
satisfied, its head is "added to" to the set of proven facts.
When a message declaration is used in the head of a clause, the clause is
treated as "message publication," i.e. when the conditions are satisfied,
the outside world is told about the addition (or removal, in some cases)
of that proven fact. The outside world may observe the same message published
multiple times.

In the following code, `tc(From, To)` is the clause head, and everything
between the `:` and the `.` is the clause body.

```
tc(From, To) : tc(From, X), tc(X, To).
```
