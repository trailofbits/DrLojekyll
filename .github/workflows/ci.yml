name: Continuous Integration

on:
  push:
    branches:
      - master
  pull_request:

env:
  DR_INSTALL_DIR: "${{ github.workspace }}/installation"

# A full build matrix would vary at least the following:
#
#     - Sanitizers: enabled or disabled
#     - Build mode: debug or release
#     - Fuzzing: enabled or disabled
#     - macOS / several LTS versions of ubuntu / windows
#     - gcc 8 / clang 6.0 / clang 9 / gcc 9 / ...
#     - ninja / makefiles / visual studio solution / xcode
#
# This would be hundreds of configurations, and it would be silly to test all
# of them.  Instead, we pick a few notable points from this matrix, to try to
# maximize problem detection ability with a minimal number of configurations.
jobs:
  build1:
    name: Ubuntu 18.04 / GCC 8 / Debug
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: >
          cmake
          -B build
          -DCMAKE_BUILD_TYPE=Debug
          -DCMAKE_C_COMPILER=gcc-8
          -DCMAKE_CXX_COMPILER=g++-8
          -DWARNINGS_AS_ERRORS=1
          -DENABLE_TEST_MYPY_CHECKS=OFF
          -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR"
          .
      - name: Build
        run: make -C build -j "$(nproc)"

      - name: Test
        run: cd build && ctest --output-on-failure -j 2 --schedule-random

      - name: Install
        run: |
          cmake --build build --target install
          rm -rf build

      - name: Test Install
        run: |
          cd tests/external_build
          cmake -B build \
            -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR" \
            -DCMAKE_C_COMPILER=gcc-8 \
            -DCMAKE_CXX_COMPILER=g++-8 \
            .
          cmake --build build

  build2:
    name: Ubuntu 18.04 / Clang 6.0 / Release
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: >
          cmake -B build
          -DCMAKE_BUILD_TYPE=RelWithDebInfo
          -DCMAKE_C_COMPILER=clang-6.0
          -DCMAKE_CXX_COMPILER=clang++-6.0
          -DWARNINGS_AS_ERRORS=1
          -DENABLE_TEST_MYPY_CHECKS=OFF
          -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR"
          .
      - name: Build
        run: cmake --build build -j "$(nproc)"

      - name: Test
        run: cd build && ctest --output-on-failure -j 2 --schedule-random

      - name: Install
        run: cmake --build build --target install

      - name: Test Install
        run: |
          cd tests/external_build
          cmake -B build \
            -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR" \
            -DCMAKE_C_COMPILER=clang-6.0 \
            -DCMAKE_CXX_COMPILER=clang++-6.0 \
            .
          cmake --build build

  build3:
    name: Ubuntu 20.04 / Clang 10 / Multi-Config / Fuzz / Sanitizers
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - name: Install Dependencies
        run: |
          export DEBIAN_FRONTEND=noninteractive
          sudo apt-get update
          sudo apt-get install ninja-build clang-10
      - name: Configure
        run: >
          cmake -B build
          -G 'Ninja Multi-Config'
          -DCMAKE_C_COMPILER=clang-10
          -DCMAKE_CXX_COMPILER=clang++-10
          -DENABLE_SANITIZERS=1
          -DENABLE_LIBFUZZER=1
          -DWARNINGS_AS_ERRORS=1
          -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR"
          .

      # We ought to be able to build multiple configurations without them
      # interfering.  First build debug, explicitly invoking `ninja`:
      - name: Build Debug
        run: ninja -C build -f build-Debug.ninja

      - name: Install Debug
        run: cmake --install build --config Debug

      - name: Test Debug Install
        run: |
          cd tests/external_build
          cmake -B build \
            -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR" \
            -DCMAKE_C_COMPILER=clang-10 \
            -DCMAKE_CXX_COMPILER=clang++-10 \
            .
          cmake --build build

      # Just a quick test to make sure the fuzzers don't crash immediately.
      # More thorough fuzzing is done in a separate GitHub Actions workflow.
      - name: Debug Parser Fuzzer Sanity Check
        run: |
          mkdir -p parser-fuzz-run/Debug
          cp -r data/examples parser-fuzz-run/Debug/corpus
          cd parser-fuzz-run/Debug
          if ! ../../build/fuzz/Debug/drlojekyll-parser-fuzzer \
                 -max_total_time=3 \
                 -timeout=1 \
                 -max_len=400 \
                 -print_final_stats=1 \
                 -dict=../../fuzz/dict.txt \
                 -exact_artifact_path=boom.txt \
                 corpus; then
            echo >&2 "Parser fuzzer smoke test failed!"
            echo >&2 "Base64-encoded input that triggered the failure:"
            base64 >&2 boom.txt
            exit 1
          fi

      - name: Debug Backend Fuzzer Sanity Check
        run: |
          mkdir -p backend-fuzz-run/Debug
          cp -r data/self_testing_examples backend-fuzz-run/Debug/corpus
          cd backend-fuzz-run/Debug
          if ! ../../build/fuzz/Debug/drlojekyll-backend-fuzzer \
                 -max_total_time=60 \
                 -timeout=3 \
                 -print_final_stats=1 \
                 -exact_artifact_path=boom.txt \
                 corpus; then
            echo >&2 "Backend fuzzer smoke test failed!"
            echo >&2 "Base64-encoded input that triggered the failure:"
            base64 >&2 boom.txt
            exit 1
          fi

      # Next, build RelWithDebInfo, using the indirect `cmake --build`
      # invocation of ninja.
      - name: Build Release
        run: cmake --build build --config RelWithDebInfo -j

      - name: Install Release
        run: cmake --install build --config RelWithDebInfo

      - name: Test Release Install
        run: |
          cd tests/external_build
          cmake -B build \
            -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR" \
            -DCMAKE_C_COMPILER=clang-10 \
            -DCMAKE_CXX_COMPILER=clang++-10 \
            .
          cmake --build build

      - name: Test Release
        run: cd build && ctest -C RelWithDebInfo --output-on-failure -j 2 --schedule-random

      # Just a quick test to make sure the fuzzers don't crash immediately.
      # More thorough fuzzing is done in a separate GitHub Actions workflow.
      - name: Release Parser Fuzzer Sanity Check
        run: |
          mkdir -p parser-fuzz-run/RelWithDebInfo
          cp -r data/examples parser-fuzz-run/RelWithDebInfo/corpus
          cd parser-fuzz-run/RelWithDebInfo
          if ! ../../build/fuzz/RelWithDebInfo/drlojekyll-parser-fuzzer \
                 -max_total_time=3 \
                 -timeout=1 \
                 -max_len=400 \
                 -print_final_stats=1 \
                 -dict=../../fuzz/dict.txt \
                 corpus; then
            echo >&2 "Fuzzing smoke test failed!"
            echo >&2 "Base64-encoded input that triggered the failure:"
            base64 >&2 boom.txt
            exit 1
          fi

      - name: Release Backend Fuzzer Sanity Check
        run: |
          mkdir -p backend-fuzz-run/RelWithDebInfo
          cp -r data/self_testing_examples backend-fuzz-run/RelWithDebInfo/corpus
          cd backend-fuzz-run/RelWithDebInfo
          if ! ../../build/fuzz/RelWithDebInfo/drlojekyll-backend-fuzzer \
                 -max_total_time=3 \
                 -timeout=3 \
                 -print_final_stats=1 \
                 -exact_artifact_path=boom.txt \
                 corpus; then
            echo >&2 "Backend fuzzer smoke test failed!"
            echo >&2 "Base64-encoded input that triggered the failure:"
            base64 >&2 boom.txt
            exit 1
          fi


  build4:
    name: macOS 10.15 / Debug / Sanitizers
    runs-on: macos-10.15
    steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: >
          cmake
          -B build
          -G Xcode
          -DENABLE_SANITIZERS=1
          -DWARNINGS_AS_ERRORS=1
          -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR"
          .
      - name: Build
        run: cmake --build build --config Debug -j "$(sysctl -n hw.ncpu)"

      - name: Test
        run: cd build && ctest --output-on-failure -j 2 --schedule-random

      - name: Install
        run: cmake --install build --config Debug

      - name: Test Install
        run: |
          cd tests/external_build
          cmake -B build -G Xcode -DCMAKE_INSTALL_PREFIX="$DR_INSTALL_DIR" .
          cmake --build build

  build5:
    name: Windows Server 2019 / Debug
    runs-on: windows-2019
    steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: >
          cmake
          -B build
          -G "Visual Studio 16 2019"
          -DWARNINGS_AS_ERRORS=0
          -DENABLE_TEST_MYPY_CHECKS=OFF
          -DCMAKE_INSTALL_PREFIX="$env:DR_INSTALL_DIR"
          .
      - name: Build
        run: cmake --build build --config Debug -j

      - name: Test
        shell: cmd
        run: |
          call "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
          cd build
          ctest --output-on-failure -j 2 --schedule-random

      - name: Install
        run: cmake --install build --config Debug

      - name: Test Install
        run: |
          cd tests/external_build
          cmake -B build -DCMAKE_INSTALL_PREFIX="$env:DR_INSTALL_DIR" -G "Visual Studio 16 2019" .
          cmake --build build

  build6:
    name: Ubuntu 18.04 / Clang 8 / Release / Tests Disabled
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2
      - name: Configure
        run: >
          cmake -B build
          -DCMAKE_BUILD_TYPE=Release
          -DCMAKE_C_COMPILER=clang-8
          -DCMAKE_CXX_COMPILER=clang++-8
          -DWARNINGS_AS_ERRORS=1
          -DENABLE_TESTS=0
          .
      - name: Build
        run: make -C build -j "$(nproc)"

  build7:
    name: Docker image
    runs-on: ubuntu-latest
    env:
      DOCKER_TAG: "docker.pkg.github.com/trailofbits/drlojekyll/drlojekyll:latest"
    steps:
      - uses: actions/checkout@v2
      - name: Build Docker image
        run: |
          docker build -t "$DOCKER_TAG" --target=dist .
          # Test library copy/build here to take advantage of Docker layer
          # caching
          docker build -t drlog_lib_test --target=test_lib .
      - name: Test Docker Executable
        run: prog=join_attributes; docker run --rm -v "$(pwd):/drlog/local" -w /drlog/local "$DOCKER_TAG" -dot-out "${prog}.dot" -dr-out "${prog}.dr" -ir-out "${prog}.out" -cpp-out "${prog}.cpp" "./data/examples/${prog}.dr"
      - name: Push Docker image
        if: github.event_name == 'push' && github.ref == 'refs/heads/master'
        run: |
          docker login docker.pkg.github.com -u "$GH_USER" -p "$GH_TOKEN"
          docker push "$DOCKER_TAG"
        env:
          GH_USER: ${{ github.actor }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
