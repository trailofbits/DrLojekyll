// Copyright 2019, Trail of Bits. All rights reserved.

#pragma once

#include <drlojekyll/Rel/Query.h>

#include <string>
#include <unordered_map>
#include <vector>

#include <drlojekyll/Parse/Parse.h>
#include <drlojekyll/Util/DisjointSet.h>

namespace hyde {
namespace query {

// Contextual information shared by all queries generated by the same builder.
class QueryContext {
 public:
  QueryContext(void);
  ~QueryContext(void);

  // A cache of the empty query. We may generate empty queries for some
  // clauses.
  std::weak_ptr<QueryImpl> empty_query;

  // The tables available within any query sharing this context.
  std::unordered_map<ParsedDeclaration, std::unique_ptr<Node<QueryRelation>>>
      relations;

  // Negative tables, these are basically "opposites" of normal tables.
  // Selections from negative tables must be involved in a "full" join.
  std::unordered_map<ParsedDeclaration, std::unique_ptr<Node<QueryRelation>>>
      negative_relations;

  std::unordered_map<std::string, std::unique_ptr<Node<QueryConstant>>>
      constant_integers;

  std::unordered_map<std::string, std::unique_ptr<Node<QueryConstant>>>
      constant_strings;

  // The next table.
  Node<QueryTable> *next_table{nullptr};
  Node<QueryConstant> *next_constant{nullptr};
  Node<QueryRelation> *next_relation{nullptr};
};

}  // namespace query

template <>
class Node<QueryTable> {
 public:
  virtual ~Node(void);

  inline Node(Node<QueryTable> *next_)
      : next_table(next_) {}

  virtual bool IsConstant(void) const noexcept = 0;
  virtual bool IsRelation(void) const noexcept = 0;

  // Next table, not specific to a query.
  Node<QueryTable> * const next_table;
};

template <>
class Node<QueryConstant> final : public Node<QueryTable> {
 public:
  virtual ~Node(void);

  inline Node(ParsedLiteral literal_, Node<QueryTable> *next_table_,
              Node<QueryConstant> *next_)
      : Node<QueryTable>(next_table_),
        literal(literal_),
        next(next_) {}

  bool IsConstant(void) const noexcept override;
  bool IsRelation(void) const noexcept override;

  const ParsedLiteral literal;

  // Next constant, not specific to a query.
  Node<QueryConstant> * const next;
};

template <>
class Node<QueryRelation> final : public Node<QueryTable> {
 public:
  virtual ~Node(void);

  inline Node(ParsedDeclaration decl_, Node<QueryTable> *next_table_,
              Node<QueryRelation> *next_, bool is_positive_)
      : Node<QueryTable>(next_table_),
        decl(decl_),
        next(next_),
        is_positive(is_positive_) {}

  bool IsConstant(void) const noexcept override;
  bool IsRelation(void) const noexcept override;

  const ParsedDeclaration decl;

  // Next relation, not specific to a query.
  Node<QueryRelation> * const next;

  // Is this a positive or negative table?
  const bool is_positive;
};

template <>
class Node<QueryView> {
 public:
  virtual ~Node(void);

  virtual bool IsSelect(void) const noexcept = 0;
  virtual bool IsJoin(void) const noexcept = 0;

  inline Node(QueryImpl *query_)
      : query(query_) {}

  // Query containing this view.
  QueryImpl * const query{nullptr};

  // The selected columns.
  std::vector<Node<QueryColumn> *> columns;

  // Next view (select or join) in this query.
  Node<QueryView> *next_view{nullptr};
};

template <>
class Node<QuerySelect> final : public Node<QueryView> {
 public:
  inline Node(QueryImpl *query_, Node<QueryTable> *table_)
      : Node<QueryView>(query_),
        table(table_) {}

  virtual ~Node(void);
  bool IsSelect(void) const noexcept override;
  bool IsJoin(void) const noexcept override;

  // Next select in this query.
  Node<QuerySelect> *next{nullptr};

  // The table from which this select takes its columns.
  Node<QueryTable> * const table;
};

template <>
class Node<QueryJoin> final : public Node<QueryView> {
 public:
  using Node<QueryView>::Node;

  virtual ~Node(void);
  bool IsSelect(void) const noexcept override;
  bool IsJoin(void) const noexcept override;

  // The column on which this join pivots.
  Node<QueryColumn> *pivot{nullptr};

  // Next join in this query.
  Node<QueryJoin> *next{nullptr};

  // The columns that are all joined together.
  std::vector<Node<QueryColumn> *> joined_columns;
};

template <>
class Node<QueryConstraint> {
 public:
  inline Node(ComparisonOperator op_, Node<QueryColumn> *lhs_,
              Node<QueryColumn> *rhs_)
      : lhs(lhs_),
        rhs(rhs_),
        op(op_) {}

  Node<QueryColumn> * const lhs;
  Node<QueryColumn> * const rhs;

  // Next such constraint in this query.
  Node<QueryConstraint> *next{nullptr};

  const ComparisonOperator op;
};

template <>
class Node<QueryColumn> : public DisjointSet {
 public:
  inline explicit Node(Node<QueryView> *view_, unsigned id_,
                       unsigned index_)
      : DisjointSet(id_),
        view(view_),
        index(index_) {}

  inline Node<QueryColumn> *Find(void) {
    return this->DisjointSet::FindAs<Node<QueryColumn>>();
  }

  // View to which this column belongs.
  Node<QueryView> *view;

  // Tells us this column can be found at `view->columns[index]`.
  unsigned index;

  // Next column in the whole query.
  Node<QueryColumn> *next{nullptr};

  // Next column within the same view.
  Node<QueryColumn> *next_in_view{nullptr};
};

template <>
class Node<QueryInsert> {
 public:
  inline Node(Node<QueryRelation> *relation_, ParsedDeclaration decl_)
      : relation(relation_),
        decl(decl_) {}

  Node<QueryInsert> *next{nullptr};

  Node<QueryRelation> * const relation;
  const ParsedDeclaration decl;
  std::vector<Node<QueryColumn> *> columns;
};

class QueryImpl {
 public:
  inline QueryImpl(std::shared_ptr<query::QueryContext> context_)
      : context(context_) {}

  const std::shared_ptr<query::QueryContext> context;

  Node<QuerySelect> *next_select{nullptr};
  Node<QueryView> *next_view{nullptr};
  Node<QueryJoin> *next_join{nullptr};
  Node<QueryInsert> *next_insert{nullptr};

  std::vector<std::unique_ptr<Node<QuerySelect>>> selects;
  std::vector<std::unique_ptr<Node<QueryJoin>>> joins;
  std::vector<std::unique_ptr<Node<QueryConstraint>>> constraints;
  std::vector<std::unique_ptr<Node<QueryColumn>>> columns;
  std::vector<std::unique_ptr<Node<QueryInsert>>> inserts;
};

}  // namespace hyde
